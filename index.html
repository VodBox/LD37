<html>
  <head>
    <link rel="stylesheet" href="cssReset.css">
    <script src="phaser.min.js"></script>
    <style>

    </style>
  </head>
  <body>

    <script>
      var width = window.innerWidth;
      var height = window.innerHeight;
      var yDifBottom = 0.06 * height;
      var xDifBottom = yDifBottom * 1.119;
      var yOffsetBottom = 0.932 * height;
      var game = new Phaser.Game(width, height, Phaser.AUTO, '', { preload: preload, create: create, update: update });

      function preload() {
        game.load.image('IDLogo', './insanedolllogo.png');
        game.load.image('Background', './background.png');
        game.load.image('Grid Overlay', './overlayGrid.png');
        game.load.image('Basic Cube 1', './furniture/1x1x1/0/0000.png');
        game.load.image('Basic Cube 2', './furniture/1x1x1/0/0001.png');
        game.load.image('Basic Cube 3', './furniture/1x1x1/0/0002.png');
        game.load.image('Basic Cube 4', './furniture/1x1x1/0/0003.png');
      }

      function create() {
        game.input.mouse.capture = true;
        game.stage.backgroundColor = "#0077AA";
        background = game.add.sprite(0, 0, 'Background');
        background.height = height;
        background.width = height / 9 * 16;
        background.x = -(background.width - width) / 2;
        logo = game.add.sprite(0, 0, 'IDLogo');
        logo.age = 120;
        //leftKey = game.input.keyboard.addKey(Phaser.Keyboard.LEFT);
        //rightKey = game.input.keyboard.addKey(Phaser.Keyboard.RIGHT);
        upKey = game.input.keyboard.addKey(Phaser.Keyboard.UP);
        downKey = game.input.keyboard.addKey(Phaser.Keyboard.DOWN);
      }

      var coords = [];

      function initCoords() {
        for(var x = 0; x < 6; ++x) {
          coords[x] = [];
          for(var y = 0; y < 6; ++y) {
            coords[x][y] = [];
            for(var z = 0; z < 6; ++z) {
              coords[x][y][z] = false;
            }
          }
        }
      }

      var padding = 0.15;

      function coordsToScreen(x, y) {
        return {
          x: (width / 2) - (xDifBottom * x) + (xDifBottom * y),
          y: yOffsetBottom - yDifBottom * ((12 - y) / 2) + yDifBottom * (x / 2)
        };
      }

      function drawBottomPiece(x,y) {
        var piece = game.add.group();

        var pointStart = {
          x: (width / 2) - (xDifBottom * x) + (xDifBottom * y),
          y: yOffsetBottom - yDifBottom * ((12 - y) / 2) + yDifBottom * (x / 2)
        };

        var quad = game.make.graphics(0,0);
        if(clicked) {
          quad.beginFill(0xCC5555);
        } else {
          quad.beginFill(0x55CCFF);
        }
        var pointsQuad = [];
        pointsQuad[0] = {x: pointStart.x, y: pointStart.y};
        pointsQuad[1] = {x: pointStart.x + xDifBottom, y: pointStart.y + (yDifBottom / 2)};
        pointsQuad[2] = {x: pointStart.x, y: pointStart.y + yDifBottom};
        pointsQuad[3] = {x: pointStart.x - xDifBottom, y: pointStart.y + (yDifBottom / 2)};
        quad.drawPolygon(pointsQuad);
        quad.endFill();
        quad.alpha = 0.6;
        piece.add(quad);

        var padded = game.make.graphics(0,0);
        if(clicked) {
          padded.beginFill(0xFF5555);
        } else {
          padded.beginFill(0x0099FF);
        }
        var points = [];
        points[0] = {x: pointStart.x, y: pointStart.y + (yDifBottom * padding)};
        points[1] = {x: pointStart.x + (xDifBottom * (1 - (padding * 2))), y: pointStart.y + (yDifBottom / 2)};
        points[2] = {x: pointStart.x, y: pointStart.y + yDifBottom - (yDifBottom * padding)};
        points[3] = {x: pointStart.x - (xDifBottom * (1 - (padding * 2))), y: pointStart.y + (yDifBottom / 2)};
        padded.drawPolygon(points);
        padded.endFill();
        padded.alpha = 0.3;
        piece.add(padded);

        piece.alpha = 0.5;

        return piece;
      }

      var init = false;
      var bounds = [];

      function runSim() {
        if(!init) {
          init = true;
          initCoords();
          gameObject = game.add.group();
          background.destroy();
          background = game.make.sprite(0, 0, 'Background');
          background.height = height;
          background.width = height / 9 * 16;
          background.x = -(background.width - width) / 2;
          gameObject.add(background);
          currentHover = drawBottomPiece(0,0);
          gameObject.add(currentHover);
          overlay = game.make.sprite(0, 0, 'Grid Overlay');
          overlay.height = height;
          overlay.width = height / 9 * 16;
          overlay.x = -(overlay.width - width) / 2;
          roomItems = game.make.group();
          //gameObject.add(overlay);
          gameObject.add(roomItems);
          makeGrid();
          addBounds();
        }
        iterate();
      }

      function addBounds() {
        for(var x = 0; x < 6; ++x) {
          bounds[x] = [];
          for(var y = 0; y < 6; ++y) {
            bounds[x][y] = {
              x: (width / 2) - (xDifBottom * x) + (xDifBottom * y),
              y: yOffsetBottom - yDifBottom * ((12 - y) / 2) + yDifBottom * (x / 2)
            }
          }
        }
      }

      function checkBounds(mouseX, mouseY) {
        for(var x = 0; x < 6; ++x) {
          for(var y = 0; y < 6; ++y) {
            if(mouseX > bounds[x][y].x - xDifBottom
            && mouseX < bounds[x][y].x + xDifBottom
            && mouseY > bounds[x][y].y
            && mouseY < bounds[x][y].y + yDifBottom) {
              var dx = mouseX - bounds[x][y].x + xDifBottom;
              if(dx > xDifBottom) {
                dx = Math.abs(bounds[x][y].x + xDifBottom - mouseX);
              }
              dx = (dx / xDifBottom) / 2;
              console.log(dx);
              if(mouseY > bounds[x][y].y + (yDifBottom * (0.5 - dx))
              && mouseY < bounds[x][y].y + yDifBottom - (yDifBottom * (0.5 - dx))) {
                if(currentHover) {
                  currentHover.destroy();
                }
                currentHover = drawBottomPiece(x,y);
                return [x, y];
              }
            }
          }
        }
        if(currentHover) {
          currentHover.destroy();
        }
      }

      var currentZ = 0;
      var easedZ = [0,0,0,0,0,0,0];
      var cooldown = 20;
      var cooldownTime = 8;

      var clicked = false;

      var spawnCooldown = 300;

      var gravityInterval = 60;

  	  function iterate() {
        if(game.input.activePointer.leftButton.isDown) {
          clicked = true;
        } else {
          clicked = false;
        }
        gameCoords = checkBounds(game.input.mousePointer.x, game.input.mousePointer.y);
        if(upKey.isDown && cooldown < 0) {
          currentZ += 1;
          cooldown = cooldownTime;
        }
        if(downKey.isDown && cooldown < 0) {
          currentZ -= 1;
          cooldown = cooldownTime;
        }
        if(currentZ > 5) {
          currentZ = 5;
        } else if(currentZ < 0) {
          currentZ = 0;
        }
        easedZ.shift();
        easedZ.push(currentZ);
        resultZ = 0;
        for(var i = 0, l = easedZ.length; i < l; ++i) {
          resultZ += easedZ[i] / l;
        }
        gameObject.y = resultZ * yDifBottom * 1.41;
        overlay.y = -resultZ * yDifBottom * 1.41;
        cooldown--;
        if(spawnCooldown == 0) {
          var valid = false;
          while(!valid) {
            var theX = Math.floor(Math.random() * 6);
            var theY = Math.floor(Math.random() * 6);
            console.log(theX);
            console.log(theY);
            if(!coords[theX][theY][5]) {
              var item = spawnRandomItem(theX, theY, 5);
              if(placementValid(item, theX, theY, 5)) {
                var object = game.make.sprite(0, 0, 'Basic Cube ' + Math.floor(Math.random() * 4 + 1));
                var screenCoords = coordsToScreen(theX, theY);
                object.x = screenCoords.x - xDifBottom;
                object.y = screenCoords.y - (yDifBottom * 1.41 * 6);
                object.width = xDifBottom * 2;
                object.height = xDifBottom * 2;
                object.prop = item;
                roomItems.add(object);
                modifyCoord(item, theX, theY, 5, true);
                valid = true;
              }
            }
          }
          spawnCooldown = 10;
        }
        spawnCooldown--;
        if(gravityInterval == 0) {
          doGravity();
          gravityInterval = 3;
        }
        gravityInterval--;
        redrawObjects();
  	  }

      function makeGrid() {
        for(var x = 0; x < 6; ++x) {
          for(var y = 0; y < 6; ++y) {
            var pointStart = {
              x: (width / 2) - (xDifBottom * x) + (xDifBottom * y),
              y: yOffsetBottom - yDifBottom * ((12 - y) / 2) + yDifBottom * (x / 2)
            };
            var quad = game.make.graphics(0,0);
            var pointsQuad = [];
            pointsQuad[0] = {x: pointStart.x, y: pointStart.y};
            pointsQuad[1] = {x: pointStart.x + xDifBottom, y: pointStart.y + (yDifBottom / 2)};
            pointsQuad[2] = {x: pointStart.x, y: pointStart.y + yDifBottom};
            pointsQuad[3] = {x: pointStart.x - xDifBottom, y: pointStart.y + (yDifBottom / 2)};
            quad.beginFill(0x000000);
            quad.lineStyle(5, 0xFFFFFF);
            quad.moveTo(pointsQuad[0].x, pointsQuad[0].y);
            quad.lineTo(pointsQuad[1].x, pointsQuad[1].y);
            quad.lineTo(pointsQuad[2].x, pointsQuad[2].y);
            quad.lineTo(pointsQuad[3].x, pointsQuad[3].y);
            quad.lineTo(pointsQuad[0].x, pointsQuad[0].y);
            quad.endFill();
            quad.alpha = 0.6;
            quad.gameX = x;
            quad.gameY = y;
            quad.z = x + y - currentZ;
            quad.isGrid = true;
            roomItems.add(quad);
          }
        }
      }

      function redrawObjects() {
        for(var i = 0, l = roomItems.children.length; i < l; ++i) {
          if(!roomItems.children[i].isGrid) {
            var drawZ = 0;
            roomItems.children[i].prop.easedZ.shift();
            roomItems.children[i].prop.easedZ.push(roomItems.children[i].prop.z);
            for(var e = 0, o = roomItems.children[i].prop.easedZ.length; e < o; ++e) {
              drawZ += roomItems.children[i].prop.easedZ[e] / o;
            }
            var resultingCoords = coordsToScreen(roomItems.children[i].prop.x, roomItems.children[i].prop.y);
            roomItems.children[i].x = resultingCoords.x - xDifBottom;
            roomItems.children[i].y = resultingCoords.y - (yDifBottom * 1.41 * (1 + drawZ)) + (yDifBottom * 0.1);
            roomItems.children[i].z = roomItems.children[i].prop.x + roomItems.children[i].prop.y - ((6 - roomItems.children[i].prop.z) / 20);
            roomItems.children[i].tint = (14 * (3 + roomItems.children[i].prop.x + roomItems.children[i].prop.y + roomItems.children[i].prop.z)) * 65536
                                        + (14 * (4 + roomItems.children[i].prop.x + roomItems.children[i].prop.y)) * 256
                                        + (14 * (5 + roomItems.children[i].prop.x + roomItems.children[i].prop.y - roomItems.children[i].prop.z));
          } else {
            roomItems.children[i].z = roomItems.children[i].gameX + roomItems.children[i].gameY - ((6 - currentZ) / 19);
            roomItems.children[i].y = -resultZ * yDifBottom * 1.41;
          }
        }
        roomItems.sort('z', Phaser.Group.SORT_ASCENDING);
      }

      function modifyCoord(item, x, y, z, bool) {
        for(var cube = 0, l = item.cubes.length; cube < l; ++cube) {
          coords[x + item.cubes[cube].x][y + item.cubes[cube].y][z + item.cubes[cube].z] = bool;
        }
      }

      function placementValid(item, x, y, z) {
        for(var cube = 0, l = item.cubes.length; cube < l; ++cube) {
          if(x + item.cubes[cube].x < 6 && x + item.cubes[cube].x > -1
          && y + item.cubes[cube].y < 6 && y + item.cubes[cube].y > -1
          && z + item.cubes[cube].z < 6 && z + item.cubes[cube].z > -1) {
            if(coords[x + item.cubes[cube].x][y + item.cubes[cube].y][z + item.cubes[cube].z]) {
              return false;
            }
          } else {
            return false;
          }
        }
        return true;
      }

      function spawnRandomItem(x, y, z) {
        var o = roomItems.length;
        var properties = {
          cubes: [
            {x: 0, y: 0, z: 0}//,
            //{x: 1, y: 0, z: 0}
          ],
          x: x,
          y: y,
          z: z,
          easedZ: [z,z,z,z,z]
        };
        return properties;
      }

      function doGravity() {
        for(var i = 0, l = roomItems.children.length; i < l; ++i) {
          if(!roomItems.children[i].isGrid) {
            var validDown = true;
            for(var cubes = 0, o = roomItems.children[i].prop.cubes.length; cubes < o; ++cubes) {
              if(roomItems.children[i].prop.z > 0) {
                if(placementValid(roomItems.children[i].prop, roomItems.children[i].prop.x, roomItems.children[i].prop.y, roomItems.children[i].prop.z - 1)) {
                  modifyCoord(roomItems.children[i].prop, roomItems.children[i].prop.x, roomItems.children[i].prop.y, roomItems.children[i].prop.z, false);
                  roomItems.children[i].prop.z -= 1;
                  modifyCoord(roomItems.children[i].prop, roomItems.children[i].prop.x, roomItems.children[i].prop.y, roomItems.children[i].prop.z, true);
                }
              }
            }
          }
        }
      }

      var logoVisible = true;

      function update() {
        if(logoVisible) {
          if(logo.age > -1) {
            logo.age--;
            if(logo.age < 31) {
              logo.alpha = logo.age / 30;
            }
          } else if(logo.age == -1) {
            logo = null;
            logoVisible = false;
          }
        } else {
          runSim();
        }
      }
    </script>
  </body>
</html>
